# Implementation Plan: Evil Ring Visibility Mode

**Branch**: `019-evil-ring-visibility` | **Date**: 2025-12-30 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/019-evil-ring-visibility/spec.md`

## Summary

Evil Ring Visibility Mode is a new game configuration where evil players only see ONE teammate each in a circular chain pattern (A→B→C→A). Each evil player sees only their known teammate's name (not role). The mode requires 3+ non-Oberon evil players and is compatible with all existing Merlin visibility modes. Ring assignments are stored server-side and persist for the entire game duration.

## Technical Context

**Language/Version**: TypeScript 5.x, React 18.x, Next.js 14.x (App Router)
**Primary Dependencies**: React, Next.js, Supabase, Tailwind CSS
**Storage**: Supabase Postgres with RLS
**Testing**: Vitest for unit tests
**Target Platform**: Web (Desktop-first, mobile-functional)
**Project Type**: Web application (Next.js monorepo)
**Performance Goals**: Real-time updates within 2 seconds (existing SLA)
**Constraints**: Ring assignments never exposed to clients in full; only individual player's known teammate is revealed
**Scale/Scope**: Same as existing application (5-10 players per game)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| **I. Purpose & Vision** | ✅ Pass | Extends core Avalon gameplay with new strategic mode |
| **II. Tech Stack** | ✅ Pass | Uses existing React/Next.js/Supabase stack |
| **III. Data & Security** | ✅ Pass | Ring assignments stored server-side only; RLS enforced |
| **IV. Code Quality** | ✅ Pass | Domain logic in `lib/domain/`; small focused functions |
| **V. Testing** | ✅ Pass | Unit tests for ring formation logic |
| **VI. UX & Product** | ✅ Pass | Clear toggle with prerequisite validation; consistent patterns |
| **VII. Workflow** | ✅ Pass | Follows spec-driven development flow |

**All gates passed. Proceeding to design.**

## Project Structure

### Documentation (this feature)

```text
specs/019-evil-ring-visibility/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Phase 0 output
├── quickstart.md        # Phase 1 output
├── checklists/          # Validation checklists
│   └── requirements.md
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
src/
├── types/
│   ├── role-config.ts          # MODIFY: Add evil_ring_visibility_enabled
│   └── game.ts                 # MODIFY: Add EvilRingVisibility types
├── lib/
│   ├── domain/
│   │   ├── evil-ring-visibility.ts  # NEW: Ring formation and visibility logic
│   │   ├── visibility.ts            # MODIFY: Add getEvilRingVisibility()
│   │   └── role-config.ts           # MODIFY: Add prerequisite validation
│   └── supabase/
│       └── games.ts                 # MODIFY: Add ring assignment columns
├── components/
│   ├── RoleConfigPanel.tsx      # MODIFY: Add toggle with prerequisite
│   ├── RolesInPlay.tsx          # MODIFY: Add indicator
│   └── RoleRevealModal.tsx      # MODIFY: Add ring visibility display
└── app/
    └── api/
        └── rooms/[code]/
            └── distribute/route.ts  # MODIFY: Form ring during distribution

supabase/
└── migrations/
    └── 019_evil_ring_visibility.sql  # NEW: Add columns to games table

tests/
└── unit/
    └── domain/
        └── evil-ring-visibility.test.ts  # NEW: Ring formation tests
```

## High-Level Architecture

### Data Flow

```
Room Config → Role Distribution → Ring Formation → Visibility Lookup
     ↓              ↓                   ↓                 ↓
evil_ring_    roles assigned    evil_ring_         getEvilRingVisibility()
visibility_   to players        assignments        returns 1 teammate name
enabled                         stored in DB
```

### Ring Formation Algorithm

```typescript
// Input: Array of non-Oberon evil player IDs
// Output: Map<playerId, knownPlayerId>

function formEvilRing(evilPlayerIds: string[]): Record<string, string> {
  // Shuffle to randomize ring order
  const shuffled = shuffleArray([...evilPlayerIds]);

  // Create circular chain: each player knows the next one
  const ringAssignments: Record<string, string> = {};
  for (let i = 0; i < shuffled.length; i++) {
    const currentPlayer = shuffled[i];
    const nextPlayer = shuffled[(i + 1) % shuffled.length];
    ringAssignments[currentPlayer] = nextPlayer;
  }

  return ringAssignments;
}

// Example: [A, B, C] shuffled to [B, C, A]
// Ring: B→C, C→A, A→B
```

### Database Schema Changes

```sql
-- New columns on games table
ALTER TABLE games ADD COLUMN evil_ring_assignments JSONB;

-- Example value:
-- {"player_id_1": "player_id_2", "player_id_2": "player_id_3", "player_id_3": "player_id_1"}
```

### API Contract Changes

**GET /api/rooms/[code]/role** (role reveal)
- Response extended with:
```typescript
{
  // ... existing fields
  evil_ring_visibility?: {
    enabled: true;
    known_teammate: { id: string; name: string };
    hidden_count: number;  // Other evil + Oberon count
    explanation: string;   // "Ring Visibility Mode: You only know one teammate."
  };
}
```

## Implementation Phases

### Phase 1: Database & Types (Foundation)

1. Create migration `019_evil_ring_visibility.sql`
2. Add `evil_ring_visibility_enabled` to `RoleConfig` type
3. Add ring assignment types to `game.ts`
4. Update `RoleConfig` validation in `role-config.ts`

### Phase 2: Domain Logic (Core)

1. Create `evil-ring-visibility.ts` with:
   - `canEnableEvilRingVisibility()` - prerequisite check
   - `formEvilRing()` - ring formation algorithm
   - `getEvilRingVisibility()` - visibility lookup for evil player
   - `calculateHiddenCount()` - count hidden evil including Oberon
2. Update `visibility.ts` to call ring logic when enabled

### Phase 3: UI Configuration (Toggle)

1. Add toggle to `RoleConfigPanel.tsx` with:
   - Disabled state when < 3 non-Oberon evil
   - Tooltip explaining prerequisite
   - Auto-disable logic when Oberon/player count changes
2. Add indicator to `RolesInPlay.tsx`

### Phase 4: Role Reveal (Display)

1. Update `/api/rooms/[code]/distribute/route.ts` to form ring
2. Update `/api/rooms/[code]/role/route.ts` to return ring visibility
3. Update `RoleRevealModal.tsx` to display ring visibility for evil

### Phase 5: Testing & Polish

1. Unit tests for ring formation and visibility
2. Integration testing with various player counts
3. UI polish and accessibility

## Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Ring storage | JSONB column | Matches split intel pattern; flexible structure |
| Prerequisite enforcement | UI-level disable + server validation | Consistent with Oberon Split Intel pattern |
| Name-only visibility | No role revealed | Per clarification: adds mystery |
| Hidden count includes Oberon | Yes | Per clarification: total hidden info |
| Auto-disable on config change | Yes | Prevents invalid configurations |

## Dependencies

- Existing `shuffleArray()` from `decoy-selection.ts`
- Existing `RoleConfig` validation pattern from `role-config.ts`
- Existing toggle pattern from `RoleConfigPanel.tsx`
- Existing role reveal pattern from `RoleRevealModal.tsx`

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Ring logic complexity | Medium | Follow existing split intel pattern |
| UI prerequisite edge cases | Low | Comprehensive unit tests for validation |
| Performance with large rings | Low | Max 4 evil players = simple iteration |

## Complexity Tracking

> No constitution violations. All patterns follow existing conventions.
